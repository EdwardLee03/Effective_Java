/**
 * <h2>第16条：复合优先于继承</h2>
 * <p/>
 * 继承（实现继承，implementation inheritance，一个类扩展另一个类）是<b><i>实现代码重用的有力手段，
 * 但它并非永远是完成这项工作的最佳工具。
 * 使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的。</i></b>
 * 对于专门为了继承而设计、并且具有很好的文档说明的类来说（见第17条），使用继承也是非常安全的。
 * 然而，对于普通的具体类（concrete class）进行<b><i>跨越包边界的继承，则是非常危险的</i></b>。
 * <p/>
 * <b><i>与方法调用不同的是，继承打破了封装性。即子类依赖于其超类中特定功能的实现细节。</i></b>
 * 超类的实现有可能会随着发行版本的不同而有所变化，如果真的发生了变化，
 * 子类可能会遭到破坏，即使它的代码完全没有改变。
 * <p/>
 * 导致子类脆弱的一个相关的原因是，它们的超类在后续的发行版本中可以获得新的方法。
 * <p/>
 * 上面这两个问题都来源于<b><i>覆盖（overriding）动作</i></b>。
 * <p/>
 * <b><i>幸运的是，有一种办法可以避免前面提到的所有问题。</i></b>
 * 不用扩展现有的类，而是<b><i>在新的类中增加一个私有域，它引用现有类的一个实例</i></b>。
 * 这种设计被称作<b><i>“复合（composition）”</i></b>，因为现有的类变成了新类的一个组件。
 * <b><i>新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。</i></b>
 * 这被称为<b><i>转发（forwarding）</i></b>，新类中的方法被称为<b><i>转发方法（forwarding method）</i></b>。
 * <b><i>这样得到的类将会非常稳固，它不依赖于现有类的实现细节。</i></b>
 * 即使现有的类添加了新的方法，也不会影响新的类。
 *
 * @author xingle
 * @since 2016年05月03日 20:46
 */
package c4.g16;