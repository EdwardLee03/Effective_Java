/**
 * <h2>第15条：使可变性最小化</h2>
 * <p/>
 * <b><i>不可变类</i></b>只是<b><i>其实例不能被修改的类</i></b>。
 * 每个实例中包含的<b><i>所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变</i></b>。
 * Java 平台类库中包含许多不可变的类，其中有 {@link java.lang.String}、
 * 基本类型的包装类（{@link java.lang.Integer}）、{@link java.math.BigDecimal BigDecimal}。
 * 存在不可变的类有许多理由：<b><i>不可变的类比可变类更加易于设计、实现和使用。
 * 它们不容易出错，且更加安全</i></b>。
 * <p/>
 * 为了使类成为不可变，要遵循下面五条规则：
 * <ol>
 * <li><b><i>不要提供任何会修改对象状态的方法（mutator、setter）</i></b>。</li>
 * <li><b><i>保证类不会被扩展（final）</i></b>。</li>
 * <li><b><i>使所有的域都是 final 的</i></b>。</li>
 * <li><b><i>使所有的域都成为私有的</i></b>。</li>
 * <li>确保对于<b><i>任何可变组件的互斥访问</i></b>。</li>
 * </ol>
 * <p/>
 * 可变组件的互斥访问：如果类具有<b><i>指向可变对象的域</i></b>，则<b><i>必须确保该类的
 * 客户端无法获得指向这些对象的引用</i></b>。并且，<b><i>永远不要用客户端提供的对象引用来初始化这样的域，
 * 也不要从任何访问方法中返回该对象引用。在构造器、访问方法和 readObject 方法（见第76条）中
 * 请使用保护性拷贝（defensive copy）技术（见第39条）</i></b>。
 * <p/>
 * 总之，<b><i>坚决不要为每个 get 方法编写一个相应的 set 方法。
 * 除非有很好的理由要让类成为可变的类，否则就应该是不可变的</i></b>。
 * <b><i>不可变的类有许多优点，唯一缺点是在特定的情况下存在潜在的性能问题。
 * 只有当你确认有必要实现令人满意的性能时（见第55条），才应该为不可变的类提供公有的可变配套类。</i></b>
 * <p/>
 * 如果类不能被做成是不可变的仍然应该<b><i>尽可能地限制它的可变性</i></b>。
 * 降低对象可以存在的状态数，可以更容易地分析该对象的行为，同时降低出错的可能性。
 * 因此，<b><i>除非有令人信服的理由要使域变成是非 final 的，否则要使每个域都是 final 的</i></b>。
 * <p/>
 * 可以通过 {@link java.util.TimerTask TimerTask} 类来说明这些原则。
 * <b><i>它是可变的，但是它的状态空间被有意识地设计得非常小</i></b>。
 * 你可以创建一个实例，对它进行调度使它执行起来，也可以随意地取消它。
 * <b><i>一旦一个定时器任务（timer task）已经完成，或者已经被取消，就不可能再对它重新调度</i></b>。
 *
 * @author xingle
 * @since 2016年05月02日 21:09
 */
package c4.g15;